{
    "CP Template": {
        "prefix": "cp",
        "body": [
            "/**",
            " *    author:  devangsvaghani",
            " *    created: $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
            "**/",
            "",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#ifndef ONLINE_JUDGE",
            "#include \"dev/debug.hpp\"",
            "#else",
            "#define debug(...) 8",
            "#endif",
            "",
            "typedef long long ll;",
            "typedef unsigned long long ull;",
            "typedef long double lld;",
            "",
            "#define all(x) (x).begin(), (x).end()",
            "#define f(i, x, n) for (ll i = x; i < n; i++)",
            "#define rf(i, x, n) for (ll i = x; i >= n; i--)",
            "",
            "const ll mod = 1e9+7;",
            "const ll mod2 = 998244353;",
            "const ll N = 1e6+5;",
            "",
            "void init(){",
            "    ",
            "}",
            "",
            "void solve(){",
            "    $0",
            "}",
            "",
            "int main() {",
            "    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);",
            "",
            "    // #ifndef ONLINE_JUDGE",
            "    //   freopen(\"input.txt\", \"r\", stdin);",
            "    //   freopen(\"output.txt\", \"w\", stdout);",
            "    //   freopen(\"Error.txt\", \"w\", stderr);",
            "    // #endif",
            "",
            "    init();",
            "    ",
            "    ll t = 1;",
            "    cin >> t;",
            "    for (ll T = 1; T <= t; T++) {",
            "        // debug(T);",
            "        solve();",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "CP Template"
    },
    "Ordered Set Libraries": {
        "prefix": "ordered_set_include",
        "body": [
            "#include<ext/pb_ds/assoc_container.hpp>",
            "#include<ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "// find_by_order && order_of_key",
            "template<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;",
            ""
        ],
        "description": "Ordered Set"
    },
    "Binary Exponentiation": {
        "prefix": "Binary Power",
        "body": [
            "// Binary Exponentiation",
            "long long binPower(long long a, long long b, long long m){",
            "    long long res = 1;",
            "    a %= m;",
            "    while(b > 0){",
            "        if(b & 1) res = (res * a) % m;",
            "        a = (a * a) % m;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Binary Exponentiation"
    },
    "Factorial Precomputation": {
        "prefix": "Factorial Inverse Precomputation",
        "body": [
            "// Factorial & inverse Factorial Calculation",
            "const long long factSize = 2e6 + 5;",
            "long long fact[factSize];",
            "long long invFact[factSize];",
            "",
            "void preComputeFact(){",
            "    fact[0] = 1;",
            "    for(long long i = 1; i < factSize; ++i){",
            "        fact[i] = (fact[i - 1] * i) % mod;",
            "    }",
            "    invFact[factSize - 1] = binPower(fact[factSize - 1], mod - 2, mod);",
            "    for(long long i = factSize - 2; i >= 0; --i){",
            "        invFact[i] = (invFact[i + 1] * (i + 1)) % mod;",
            "    }",
            "}"
        ],
        "description": "Factorial Precomputation"
    },
    "nCr": {
        "prefix": "nCr",
        "body": [
            "// nCr Calculation",
            "long long nCr(long long n, long long r){",
            "    if(r < 0 || r > n) return 0ll;",
            "    return ((fact[n] * invFact[n - r]) % mod * invFact[r]) % mod; ",
            "}"
        ],
        "description": "nCr"
    },
    "Derangement - Permutation such that no element appears in its original position": {
        "prefix": "Derangement",
        "body": [
            "// Derangement - Permutation such that no element appears in its original position",
            "// D[n] = (D[n - 1] + D[n - 2]) * (n - 1);",
            "// D[1] = 0, D[2] = 1;",
            "const long long derangementSize = 1e6 + 1;",
            "long long derangement[derangementSize];",
            "",
            "void preComputeDerangement(){",
            "    derangement[1] = 0;",
            "    derangement[2] = 1;",
            "",
            "    for(long long i = 3; i < derangementSize; ++i){",
            "        derangement[i] = (((derangement[i - 1] + derangement[i - 2])) % mod * (i - 1)) % mod;",
            "    }",
            "}"
        ],
        "description": "Derangement - Permutation such that no element appears in its original position"
    },
    "No. of Divisors Precomputation": {
        "prefix": "Divisors Count",
        "body": [
            "// Count number of divisors",
            "const long long divisorSize = 1e6 + 1;",
            "long long divisorsCnt[divisorSize];",
            "",
            "void preComputeDivisorsCnt(){",
            "    divisorsCnt[0] = 1;",
            "",
            "    for (long long i = 1; i * i < N; ++i){",
            "        divisorsCnt[i * i]--;",
            "        for (long long j = (i * i); j < N; j += i){",
            "            divisorsCnt[j] += 2;",
            "        }",
            "    }",
            "}",
            "",
            "bool isPrime(long long n){",
            "    return (bool)(divisorsCnt[n] == 2);",
            "}"
        ],
        "description": "No. of Divisors Precomputation"
    },
    "Eular totient function O(sqrt(n))": {
        "prefix": "phi fucntion for single number",
        "body": [
            "// Eular totient function O(sqrt(n))",
            "long long singlePhi(long long n){",
            "  long long result = n;",
            "  for(long long i = 2; i * i <= n; ++i){",
            "    if(n % i == 0){",
            "      while(n % i == 0) n /= i;",
            "      result -= result / i;",
            "    }",
            "  }",
            "",
            "  if(n > 1){",
            "    result -= result / n;",
            "  }",
            "  return result;",
            "}"
        ],
        "description": "Eular totient function O(sqrt(n))"
    },
    "Eular totient function - Precomputation": {
        "prefix": "phi fucntion",
        "body": [
            "// Eular totient function - Precomputation",
            "const long long phiSize = 1e6 + 1;",
            "long long phi[phiSize];",
            "",
            "void preComputePhi(){",
            "  for(long long i = 0; i < phiSize; ++i) phi[i] = i;",
            "",
            "  for(long long i = 2; i < phiSize; ++i){",
            "    if(phi[i] == i){",
            "      for(long long j = i; j < phiSize; j += i){",
            "        phi[j] -= phi[j] / i;",
            "      }",
            "    }",
            "  }",
            "}"
        ],
        "description": "Eular totient function - Precomputation"
    },
    "Optimised Sieve specially for N = 1e8": {
        "prefix": "Optimised Sieve",
        "body": [
            "// Optimised Sieve specially for N = 1e8",
            "const long long sieveSize = 1e8+1;",
            "bool prime[sieveSize];",
            "vector<long long> ps;",
            "",
            "void preComputeSieve(){",
            "    for(long long i = 0; i < sieveSize; i++) prime[i] = true;",
            "    for(long long i = 3; i * i < sieveSize; i += 2){",
            "        if(prime[i / 2]){",
            "            for(long long j = i * i; j < sieveSize; j += i * 2){",
            "                prime[j / 2] = false;",
            "            }",
            "        }",
            "    }",
            "",
            "    ps.push_back(2);",
            "    for(long long i = 3; i < sieveSize; i += 2){",
            "        if(prime[i / 2]){",
            "            ps.push_back(i);",
            "        }",
            "    }",
            "}"
        ],
        "description": "Optimised Sieve specially for N = 1e8"
    },
    "Sieve for prime numbers": {
        "prefix": "Sieve",
        "body": [
            "// Sieve for prime numbers",
            "const long long sieveSize = 1e7+1;",
            "bool prime[sieveSize];",
            "vector<long long> primes;",
            "",
            "void preComputeSieve(){",
            "    for(long long i = 2; i < sieveSize; ++i) prime[i] = true;",
            "    for(long long i = 2; i < sieveSize; ++i){",
            "        if(prime[i]){",
            "                primes.push_back(i);",
            "            for(long long j = i * i; j < sieveSize; j += i){",
            "                prime[j] = false;",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Sieve for prime numbers"
    },
    "DSU": {
        "prefix": "DSU",
        "body": [
            "class DSU{",
            "public:",
            "    long long n;",
            "    vector<long long> size, par;",
            " ",
            "    DSU(long long n){",
            "        this -> n = n;",
            "        size.resize(n);",
            "        par.resize(n);",
            " ",
            "        for(long long i = 0; i < n; ++i){",
            "            par[i] = i;",
            "            size[i] = 1;",
            "        }",
            "    }",
            " ",
            "    long long find(long long u){",
            "        if (u == par[u])",
            "            return u;",
            "        return par[u] = find(par[u]);",
            "    }",
            " ",
            "    void merge(long long u, long long v){",
            "        u = find(u); v = find(v);",
            "        if (u == v) return;",
            "",
            "        if (size[u] < size[v]){",
            "            swap(u, v);",
            "        } ",
            "        size[u] += size[v];",
            "        par[v] = u;",
            "    }",
            " ",
            "    long long count_components(){",
            "        long long cnt = 0;",
            "        for (long long i = 1; i < n; ++i){",
            "            if (par[i] == i) ++cnt;",
            "        }",
            " ",
            "        return cnt;",
            "    }",
            "};"
        ],
        "description": "DSU"
    },
    "2-SAT (Boolean satisfiability problem)": {
        "prefix": "2-SAT",
        "body": [
            "struct TwoSatSolver {",
            "    int n_vars;",
            "    int n_vertices;",
            "    vector<vector<int>> adj, adj_t;",
            "    vector<bool> used;",
            "    vector<int> order, comp;",
            "    vector<bool> assignment;",
            "",
            "    TwoSatSolver(int _n_vars) : n_vars(_n_vars), n_vertices(2 * n_vars), adj(n_vertices), adj_t(n_vertices), used(n_vertices), order(), comp(n_vertices, -1), assignment(n_vars) {",
            "        order.reserve(n_vertices);",
            "    }",
            "    void dfs1(int v) {",
            "        used[v] = true;",
            "        for (int u : adj[v]) {",
            "            if (!used[u])",
            "                dfs1(u);",
            "        }",
            "        order.push_back(v);",
            "    }",
            "",
            "    void dfs2(int v, int cl) {",
            "        comp[v] = cl;",
            "        for (int u : adj_t[v]) {",
            "            if (comp[u] == -1)",
            "                dfs2(u, cl);",
            "        }",
            "    }",
            "",
            "    bool solve_2SAT() {",
            "        order.clear();",
            "        used.assign(n_vertices, false);",
            "        for (int i = 0; i < n_vertices; ++i) {",
            "            if (!used[i])",
            "                dfs1(i);",
            "        }",
            "",
            "        comp.assign(n_vertices, -1);",
            "        for (int i = 0, j = 0; i < n_vertices; ++i) {",
            "            int v = order[n_vertices - i - 1];",
            "            if (comp[v] == -1)",
            "                dfs2(v, j++);",
            "        }",
            "",
            "        assignment.assign(n_vars, false);",
            "        for (int i = 0; i < n_vertices; i += 2) {",
            "            if (comp[i] == comp[i + 1])",
            "                return false;",
            "            assignment[i / 2] = comp[i] > comp[i + 1];",
            "        }",
            "        return true;",
            "    }",
            "",
            "    void add_disjunction(int a, bool na, int b, bool nb) {",
            "        // na and nb signify whether a and b are to be negated ",
            "        a = 2 * a ^ na;",
            "        b = 2 * b ^ nb;",
            "        int neg_a = a ^ 1;",
            "        int neg_b = b ^ 1;",
            "        adj[neg_a].push_back(b);",
            "        adj[neg_b].push_back(a);",
            "        adj_t[b].push_back(neg_a);",
            "        adj_t[a].push_back(neg_b);",
            "    }   ",
            "",
            "    // how to use",
            "",
            "    // Nodes are from 0 to n - 1 ( 0 indexded )",
            "",
            "    // TwoSatSolver solver(3); // a, b, c",
            "    // solver.add_disjunction(0, false, 1, true);  //     a  v  not b",
            "    // solver.add_disjunction(0, true, 1, true);   // not a  v  not b",
            "    // solver.add_disjunction(1, false, 2, false); //     b  v      c",
            "    // solver.add_disjunction(0, false, 0, false); //     a  v      a",
            "    // assert(solver.solve_2SAT() == true);",
            "    // auto expected = vector<bool>(True, False, True);",
            "    // assert(solver.assignment == expected);",
            "};"
        ],
        "description": "2-SAT (Boolean satisfiability problem)"
    },
    "Segment tree": {
        "prefix": "Segment tree",
        "body": [
            "struct segNode{",
            "    long long mx;",
            "    ",
            "    segNode(){",
            "        mx = LLONG_MIN;",
            "    }",
            "    ",
            "    void merge(segNode &x, segNode& y){",
            "        mx = max(x.mx, y.mx);",
            "    }",
            "    ",
            "    void update(long long val){",
            "        mx = val;",
            "    } ",
            "};",
            " ",
            "class segTree{",
            "    long long n;",
            "    vector<segNode> tree;",
            "    ",
            "    public:",
            "    segTree(){}",
            "",
            "    segTree(long long n){",
            "        this -> n = n;",
            "        tree.resize(4 * n);",
            "    }",
            "",
            "    segTree(vector<long long> &v, long long n){",
            "        this -> n = n;",
            "        tree.resize(4 * n);",
            "        fill(all(tree), segNode());",
            "    ",
            "        build(0, 0, n-1, v);",
            "    }",
            "    ",
            "    void build(long long node, long long l, long long r, vector<long long> &v){",
            "        if(l == r){",
            "            tree[node].update(v[l]);",
            "            return;",
            "        }",
            "    ",
            "        long long mid = l + (r - l)/2;",
            "        build(2 * node + 1, l, mid, v);",
            "        build(2 * node + 2, mid + 1, r, v);",
            "    ",
            "        tree[node].merge(tree[2 * node + 1], tree[2 * node + 2]);",
            "    }",
            "    ",
            "    void update(long long pos, long long val){",
            "        update(0, 0, n-1, pos, val);",
            "    }",
            "    ",
            "    void update(long long node, long long l, long long r, long long pos, long long val){",
            "        if(l == r){",
            "            tree[node].update(val);",
            "            return;",
            "        }",
            "    ",
            "        long long mid = l + (r - l)/2;",
            "        if(pos <= mid){",
            "            update(2 * node + 1, l, mid, pos, val);",
            "        }else{",
            "            update(2 * node + 2, mid + 1, r, pos, val);",
            "        }",
            "    ",
            "        tree[node].merge(tree[2 * node + 1], tree[2 * node + 2]);",
            "    }",
            "    ",
            "    long long query(long long s, long long e){",
            "        segNode ans = query(0, 0, n-1, s, e);",
            "        ",
            "        return ans.mx;",
            "    }",
            "    ",
            "    segNode query(long long node, long long l, long long r, long long s, long long e){",
            "        if(l >= s && r <= e) return tree[node];",
            "    ",
            "        if(l > e || r < s) return segNode();",
            "    ",
            "        long long mid = l + (r - l)/2;",
            "    ",
            "        segNode ans, left, right;",
            "        left = query(2 * node + 1, l, mid, s, e);",
            "        right = query(2 * node + 2, mid + 1, r, s, e);",
            "        ans.merge(left, right);",
            "        ",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": "Segment tree"
    },
    "Segment tree Lazy": {
        "prefix": "Segment tree lazy",
        "body": [
            "struct segNode{",
            "    long long sum, set;",
            "    ",
            "    segNode(){",
            "        sum = 0;",
            "        set = -1;",
            "    }",
            "    ",
            "    segNode(long long x){",
            "        sum = x;",
            "        set = -1;",
            "    }",
            "    ",
            "    void merge(segNode &a, segNode &b){",
            "        sum = a.sum + b.sum;",
            "    }",
            "    ",
            "    void lazy_add(ll x){",
            "        set = x;",
            "    }",
            "    ",
            "    void lazy_apply(ll l, ll r){",
            "        if(set != -1){",
            "            sum = (r - l + 1) * set;",
            "        }",
            "    }",
            "    ",
            "    void lazy_merge(segNode &par){",
            "        if(par.set != -1) set = par.set;",
            "    }",
            "    ",
            "    void lazy_remove(){",
            "        set = -1;",
            "    }",
            "}; ",
            " ",
            "class segTree{",
            "    public:",
            "    vector<segNode> tree;",
            "    long long n;",
            "    ",
            "    segTree(long long n){",
            "        this -> n = n;",
            "        tree.resize(4 * n, segNode());",
            "    ",
            "        build(0, 0, n-1);",
            "    }",
            "    ",
            "    void build(long long node, long long l, long long r){",
            "        if(l == r){",
            "            tree[node] = segNode(0);",
            "            return;",
            "        }",
            "    ",
            "        long long mid = l + (r - l)/2;",
            "        build(2 * node + 1, l, mid);",
            "        build(2 * node + 2, mid + 1, r);",
            "    ",
            "        tree[node].merge(tree[2 * node + 1], tree[2 * node + 2]);",
            "    }",
            "    ",
            "    void push(long long node, long long l, long long r){",
            "        tree[node].lazy_apply(l, r);",
            "    ",
            "        if(l != r){",
            "            tree[2 * node + 1].lazy_merge(tree[node]);",
            "            tree[2 * node + 2].lazy_merge(tree[node]);",
            "        }",
            "    ",
            "        tree[node].lazy_remove();",
            "    }",
            "    ",
            "    void update(long long s, long long e, long long x){",
            "        update(0, 0, n-1, s, e, x);",
            "    }",
            "    ",
            "    void update(long long node, long long l, long long r, long long s, long long e, long long x){",
            "        push(node, l, r);",
            "    ",
            "        if(l > e || r < s) return;",
            "        if(l >= s && r <= e){",
            "            tree[node].lazy_add(x);",
            "            push(node, l, r);",
            "            return;",
            "        }",
            "    ",
            "        long long mid = l + (r - l)/2;",
            "        update(2 * node + 1, l, mid, s, e, x);",
            "        update(2 * node + 2, mid + 1, r, s, e, x);",
            "    ",
            "        tree[node].merge(tree[2 * node + 1], tree[2 * node + 2]);",
            "    }",
            "    ",
            "    long long query(long long s, long long e){",
            "        return query(0, 0, n-1, s, e).sum;",
            "    }",
            "    ",
            "    segNode query(long long node, long long l, long long r, long long s, long long e){",
            "        push(node, l, r);",
            "    ",
            "        if(l > e || r < s) return segNode();",
            "        if(l >= s && r <= e) return tree[node];",
            "    ",
            "        long long mid = l + (r - l)/2;",
            "        segNode ans, left, right;",
            "        left = query(2 * node + 1, l, mid, s, e);",
            "        right = query(2 * node + 2, mid + 1, r, s, e);",
            "    ",
            "        ans.merge(left, right);",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": "Segment tree Lazy"
    },
    "Fenwick Tree": {
        "prefix": "Fenwick Tree",
        "body": [
            "// Fenwick Tree",
            "struct FenwickTree {",
            "    long long n;",
            "    vector<long long> s;",
            "    FenwickTree(int n) : s(n), n(n) {}",
            "",
            "    // v[pos] += dif",
            "    void update(int pos, long long dif) { ",
            "        for (; pos < n; pos |= pos + 1) s[pos] += dif;",
            "    }",
            "",
            "    // sum of values in [0, pos)",
            "    long long query(int pos) { ",
            "        long long res = 0;",
            "        for (; pos > 0; pos &= pos - 1) res += s[pos-1];",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Fenwick Tree"
    },
    "Sparse Table": {
        "prefix": "Sparse Table",
        "body": [
            "class SparseTable{",
            "    vector<vector<long long>> st;",
            "    vector<long long> lg;",
            "    long long K;",
            "    ",
            "    public:",
            "",
            "    SparseTable(vector<long long> &v, ll &n){",
            "        K = 20; // 20 for 2 * 1e5, 25 for 1e7, and so on..",
            "        st.resize(K + 1, vector<long long> (n));",
            "        lg.resize(n + 1);",
            "        preComputeLG(n);",
            "        preCompute(v, n);",
            "    }",
            "",
            "    void preComputeLG(long long &n){",
            "        lg[0] = 1;",
            "        for (long long i = 2; i <= n; i++){",
            "            lg[i] = lg[i/2] + 1;",
            "        }",
            "    }",
            "",
            "    void preCompute(vector<long long> &v, long long &n){",
            "        // st[i][j] -> range [j, j + (1long long << i) - 1]",
            "        // st[i][j] = st[i-1][j] + st[i-1][j + (1long long << (i-1))];",
            "",
            "        copy(v.begin(), v.end(), st[0].begin());",
            "",
            "        for(long long i = 1; i <= K; ++i){",
            "            for(long long j = 0; j + (1ll << i) <= n; ++j){",
            "                st[i][j] = min(st[i-1][j], st[i-1][j + (1ll << (i - 1))]);",
            "            }",
            "        }",
            "    }",
            "",
            "    // 0 - based indexing use for call function",
            "    long long query(long long l, long long r){",
            "        // sum query",
            "        // long long sum = 0;",
            "        // for (long long i = K; i >= 0; i--) {",
            "        //     if ((1 << i) <= R - L + 1) {",
            "        //         sum += st[i][L];",
            "        //         L += 1 << i;",
            "        //     }",
            "        // }",
            "",
            "        // for idempotent functions like min, max, gcd, bitwise and, bitwise or, etc...",
            "        long long i = lg[r - l + 1];",
            "        long long mn = min(st[i][l], st[i][r - (1 << i) + 1]);",
            "        return mn;",
            "    }",
            "};"
        ],
        "description": "Sparse Table"
    },
    "Hash String": {
        "prefix": "Hash String",
        "body": [
            "class HashString{",
            "    long long p = 31, m = 1e9+9;",
            "    vector<long long> h, ppow;",
            "    public:",
            " ",
            "    HashString(string &s){",
            "        int n = s.length();",
            "        h.resize(n + 1, 0);",
            "        ppow.resize(n + 1, 0);",
            "        ppow[0] = 1;",
            " ",
            "        for(int i = 1; i <= n; ++i){",
            "            ppow[i] = (ppow[i - 1] * p) % m;",
            "            h[i] = ((h[i - 1] * p) % m + (s[i - 1] - 'a' + 1)) % m;",
            "        }",
            "    }   ",
            "    ",
            "    // assume zero based indexing",
            "    long long getSubHash(int l, int r){ ",
            "        long long ans = (h[r + 1] - (h[l] * ppow[r - l + 1]) % m + m) % m;",
            "        return ans;",
            "    }",
            " ",
            "    long long getInstantHash(string &s){",
            "        long long ans = 0;",
            " ",
            "        for(auto &c : s){",
            "            ans = (ans * p) % m;",
            "            ans = (ans + (c - 'a' + 1)) % m;",
            "        }",
            " ",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": "Hash String"
    },
    "KMP Algo Prefix Function": {
        "prefix": "KMP Prefix",
        "body": [
            "// Knuth-Morris-Pratt algorithm",
            "vector<long long> prefixFunction(string &s, long long n){",
            "    vector<long long> pi(n);",
            "    pi[0] = 0;",
            "    for(long long i = 1; i < n; ++i){",
            "        long long j = pi[i-1];",
            "        while(j > 0 && s[i] != s[j]){",
            "            j = pi[j-1];",
            "        }",
            "        if(s[i] == s[j]){",
            "            j++;",
            "        }",
            "        pi[i] = j;",
            "    }",
            "    return pi;",
            "}"
        ],
        "description": "KMP Algo Prefix Function"
    },
    "Z Algorithm": {
        "prefix": "Z Algorithm",
        "body": [
            "vector<long long> z_function(string &s, long long n){",
            "    vector<long long> z(n);",
            "    z[0] = 0;",
            "    long long l = 0, r = 0;",
            "    for(long long i = 1; i < n; ++i){",
            "        if(i < r){",
            "            z[i] = min(r - i, z[i - l]);",
            "        }",
            "        while(i + z[i] < n && s[z[i]] == s[i + z[i]]){",
            "            z[i]++;",
            "        }",
            "        if(i + z[i] > r){",
            "            l = i;",
            "            r = i + z[i];",
            "        }",
            "    }",
            "    return z;",
            "}"
        ],
        "description": "Z Algorithm"
    },
    "LCA Lowest Common Ancestor": {
        "prefix": "LCA Binary Lifting",
        "body": [
            "// LCA using in out time",
            "const long long nodesCnt = 2e5 + 5;",
            "long long par[nodesCnt][20]; // 20 for 2 * 1e5, 25 for 1e7, and so on..",
            "long long in[nodesCnt], out[nodesCnt];",
            "long long timer;",
            "",
            "// Initialization ",
            "// timer = 0;",
            "// preDfs(1, 1, adj)",
            "",
            "// 1 - based indexing for nodes",
            "void preDfs(long long u, long long p, vector<vector<long long>> &adj){",
            "    in[u] = ++timer;",
            "    par[u][0] = p;",
            "    ",
            "    for(long long i = 1; i < 20; ++i){",
            "        par[u][i] = par[par[u][i-1]][i-1];",
            "    }",
            "    ",
            "    for(auto &v : adj[u]){",
            "        if(v == p) continue;",
            "        preDfs(v, u, adj);",
            "    }",
            "",
            "    out[u] = ++timer;",
            "}",
            " ",
            "bool is_ancestor(long long u, long long v){",
            "    return (in[u] <= in[v] && out[u] >= out[v]);",
            "}",
            " ",
            "long long lca(long long u, long long v){",
            "    if(is_ancestor(u, v)) return u;",
            "    if(is_ancestor(v, u)) return v;",
            "    ",
            "    for(long long i = 19; i >= 0; --i){",
            "        if(!is_ancestor(par[u][i], v)){",
            "            u = par[u][i];",
            "        }",
            "    }",
            "    ",
            "    return par[u][0];",
            "}"
        ],
        "description": "LCA Lowest Common Ancestor"
    },
    "Random Number Generator": {
        "prefix": "Random Number Generator",
        "body": [
            "// unsigned long long random number, usage: rng()",
            "mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());"
        ],
        "description": "Random Number Generator"
    },
    "Mo's Algorithm": {
        "prefix": "Mo's Algorithm",
        "body": [
            "// Mo's Algorithm",
            "const ll BLOCK_SIZE = 500; // sqrt(n) or some near value",
            "",
            "// TODO: Data structures for Mo's algo",
            "",
            "// TODO: remove value at idx from data structure",
            "void remove(ll idx){",
            "",
            "};",
            "",
            "// TODO: add value at idx from data structure",
            "void add(ll idx){",
            "",
            "};",
            "",
            "// TODO: extract the current answer of the data structure",
            "ll get_answer(){",
            "",
            "}; ",
            "",
            "// l, r -> 0 based indexing",
            "struct Query { ",
            "    ll l, r, idx;",
            "    bool operator<(Query other) const",
            "    {",
            "        return make_pair(l / BLOCK_SIZE, r) <",
            "               make_pair(other.l / BLOCK_SIZE, other.r);",
            "    }",
            "};",
            "",
            "vector<ll> mo_s_algorithm(vector<Query> queries) {",
            "    vector<ll> answers(queries.size());",
            "    sort(queries.begin(), queries.end());",
            "",
            "    // TODO: initialize data structure",
            "",
            "    ll cur_l = 0;",
            "    ll cur_r = -1;",
            "    // invariant: data structure will always reflect the range [cur_l, cur_r]",
            "    for (Query q : queries) {",
            "        while (cur_l > q.l) {",
            "            cur_l--;",
            "            add(cur_l);",
            "        }",
            "        while (cur_r < q.r) {",
            "            cur_r++;",
            "            add(cur_r);",
            "        }",
            "        while (cur_l < q.l) {",
            "            remove(cur_l);",
            "            cur_l++;",
            "        }",
            "        while (cur_r > q.r) {",
            "            remove(cur_r);",
            "            cur_r--;",
            "        }",
            "        answers[q.idx] = get_answer();",
            "    }",
            "    return answers;",
            "}"
        ],
        "description": "Mo's Algorithm"
    }
}